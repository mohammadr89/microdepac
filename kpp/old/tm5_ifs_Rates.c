/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* The Reaction Rates File                                          */
/*                                                                  */
/* Generated by KPP-2.2.3 symbolic chemistry Kinetics PreProcessor  */
/*       (http://www.cs.vt.edu/~asandu/Software/KPP)                */
/* KPP is distributed under GPL, the general public licence         */
/*       (http://www.gnu.org/copyleft/gpl.html)                     */
/* (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa           */
/* (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech            */
/*     With important contributions from:                           */
/*        M. Damian, Villanova University, USA                      */
/*        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany */
/*                                                                  */
/* File                 : tm5_ifs_Rates.c                           */
/* Time                 : Fri Nov 19 10:37:06 2021                  */
/* Working directory    : /home/WUR/krol005/kpp/examples            */
/* Equation file        : tm5_ifs.kpp                               */
/* Output root filename : tm5_ifs                                   */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "tm5_ifs_Parameters.h"
#include "tm5_ifs_Global.h"
#include "tm5_ifs_Sparse.h"



/* Begin Rate Law Functions from KPP_HOME/util/UserRateLaws         */

/*  User-defined Rate Law functions
    Note: the default argument type for rate laws, as read from the equations file, is single precision
         but all the internal calculations are performed in double precision
*/
/* Arrhenius */
double  ARR( float A0, float B0, float C0 )
      {
      double ARR_RES;
                 
      ARR_RES = (double)A0 * exp( -(double)B0/TEMP ) 
                * pow( (TEMP/300.0), (double)C0 );   
           
      return (double)ARR_RES;
      }           


/* Simplified Arrhenius, with two arguments */
/* Note that the argument B0 has a changed sign when compared to ARR */
double  ARR2(  float A0, float B0 )
      {
      double ARR_RES;           

      ARR_RES =  (double)A0 * exp( (double)B0/TEMP );   
           
      return (double)ARR_RES;
      }           


double  EP2( float A0, float C0, float A2, float C2, float A3, float C3)
      {                       
      double K0, K2, K3, EP2_RES;
      
      K0 = (double)A0 * exp( -(double)C0/TEMP );
      K2 = (double)A2 * exp( -(double)C2/TEMP );
      K3 = (double)A3 * exp( -(double)C3/TEMP );
      K3 = K3*CFACTOR*1.0e+6;
      EP2_RES = K0 + K3/( 1.0+K3/K2 );
        
      return (double)EP2_RES;
      }  


double  EP3( float A1, float C1, float A2, float C2) 
      {               
      double K1, K2, EP3_RES;
      
      K1 = (double)A1 * exp(-(double)C1/TEMP);
      K2 = (double)A2 * exp(-(double)C2/TEMP);
      EP3_RES = K1 + K2*(1.0e+6*CFACTOR);
      
      return (double)EP3_RES;
      }    


double  FALL (  float A0, float B0, float C0, float A1, float B1, float C1, float CF)
      {                      
      double K0, K1, FALL_RES;
      
      K0 = (double)A0 * exp(-(double)B0/TEMP)* pow( (TEMP/300.0), (double)C0 );
      K1 = (double)A1 * exp(-(double)B1/TEMP)* pow( (TEMP/300.0), (double)C1 );
      K0 = K0*CFACTOR*1.0e+6;
      K1 = K0/K1;
      FALL_RES = (K0/(1.0+K1))*
           pow( (double)CF, ( 1.0/( 1.0+pow( (log10(K1)),2 ) ) ) );
        
      return (double)FALL_RES;
      }

/* End Rate Law Functions from KPP_HOME/util/UserRateLaws           */


/* Begin INLINED Rate Law Functions                                 */



double ARR3(double A0, double B0, double TEMP)
       {
       return A0 * exp(B0 / TEMP);
       }

double TROE_ifs(double kzero, double mzero, double kinf, 
       	    double minf, double fmulti, double MN2, double TEMP)
       {
       double k0T, kinfT, znn_b;
       k0T  = (kzero * pow((TEMP/300.), mzero)) * MN2;
       kinfT = kinf * pow((TEMP/300.), minf);
       znn_b = 0.75 - (1.27 * log10(0.35));
       return (k0T * kinfT) / (k0T + kinfT) * pow(fmulti, 
       	      log10(0.35) / (1. + pow(log10(k0T/kinfT)/znn_b, 2)));
       }

double TROE_ifs2(double kzero, double mzero, double kinf, 
       	    double minf, double fmulti, double MN2, double c1, 
	    double c2, double TEMP)
       {
       double k0T, kinfT, znn_b;
       k0T  = (kzero * pow((TEMP/300.), mzero)) * MN2 * exp(c1 / TEMP);
       kinfT = kinf * pow((TEMP/300.), minf) * exp(c2 / TEMP);
       znn_b = 0.75 - (1.27 * log10(0.35));
       return (k0T * kinfT) / (k0T + kinfT) * pow(fmulti, 
       	      log10(0.35) / (1. + pow(log10(k0T/kinfT)/znn_b, 2)));
       }

double TROE_no2oh(double kzero, double mzero, double kinf, 
       	    double fmulti, double MN2, double TEMP)
       {
       double k0T, kinfT, znn;
       k0T  = (kzero * pow((300./TEMP), mzero)) * MN2;
       kinfT = kinf;
       znn = 0.75 - (1.27 * log10(0.41));
       return (k0T * kinfT) / (k0T + kinfT) * pow(fmulti, 
       	      (log10(0.41) / (1. + pow((log10(k0T/kinfT))/znn, 2))));
       }

double TROE_cooh(double kzero, double mzero, double kinf, 
       	    double minf, double k3, double c3, double k4, 
	    double c4, double fmulti, double MN2, double TEMP)
       {
       double k0T, kinfT, kval3, kval4, kcooh;
       k0T  = (kzero * pow((300./TEMP), mzero)) * MN2;
       kinfT = kinf * pow((300./TEMP), minf);
       kval3 = k3 * pow((300./TEMP), c3);
       kval4 = (k4 * pow((300./TEMP), c4)) / MN2;
       kcooh = k0T / (1. + k0T / kinfT) * pow(fmulti, 
       	     1. / (1. + pow(log10(k0T/kinfT), 2)));
       return kcooh + (kval3 / (1. + kval3 / kval4) * pow(fmulti, 
              1. / (1. + pow(log10(kval3/kval4), 2))));
       }

double EPR(double A1, double C1, double A2, double C2, 
           double A3, double C3, double mmult, double ch2o,
	   double TEMP) 
      {               
      double K1, K2, K3, EPR_p;
      
      K1 = (double)A1 * exp(C1/TEMP);
      K2 = (double)A2 * exp(C2/TEMP) * mmult;
      K3 = (double)A3 * exp(C3/TEMP) * ch2o;
      EPR_p = (K1 + K2) * (1.0 + K3);
      
      return (double)EPR_p;
      }

double k3rd_iupac(double kzero, double mzero, double kinf, 
       	    double minf, double fmulti, double MN2, double NM, double TEMP)
       {
       double k0T;
       double kinfT;
       k0T  = (kzero * pow((TEMP/300.), mzero)) * MN2;
       kinfT = kinf * pow((TEMP/300.), minf);
       return (k0T / (1. + (k0T/kinfT))) * 
       	       pow( fmulti, 1./ (1. + pow((log10(k0T/kinfT)/NM), 2) ) );
       }



/* End INLINED Rate Law Functions                                   */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Update_SUN - update SUN light using TIME                         */
/*   Arguments :                                                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void Update_SUN()
{
double SunRise, SunSet;
double Thour, Tlocal, Ttmp; 
const double PI = 3.14159265358979;  

  SunRise = 4.5;
  SunSet  = 19.5;
  Thour = TIME/3600.0;
  Tlocal = Thour - ((int)Thour/24)*24;

  if ( (Tlocal >= SunRise) && (Tlocal <= SunSet) ) {
    Ttmp = (2.0*Tlocal-SunRise-SunSet)/(SunSet-SunRise);
    if (Ttmp > 0) Ttmp =  Ttmp*Ttmp;
             else Ttmp = -Ttmp*Ttmp;
    SUN = ( 1.0 + cos(PI*Ttmp) )/2.0; 
  } else {
    SUN=0.0;
  }
}
/* End of Update_SUN function                                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Update_RCONST - function to update rate constants                */
/*   Arguments :                                                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void Update_RCONST( 
)
{


/* Begin INLINED RCONST                                             */


double C_M = 2.55E+19; // FIX[2]; 7.24291E+16*1E+5/TEMP
double C_H2 = 1.275E+13; // 500 ppb * 2.55E10
// double zh2o2 = 2.55E+10; // 1 ppb * 2.55E10
double C_H2O = 2.55E+17; // 1 percent, 0.01*Mval 
// double zo2 = 5.34E+18; // zo2 = 0.209476 * Mval
//double zno3 = 2.55E+7; // 1.E-3 ppb * 2.55E10
//double zn2o5 = 2.55E+7;

//Depositions: values are in cm/s and we assume a 1000 m high box...making the uC_M,-11000.,-11080.,TEMP))
double vdo3 = 0.5 / 1.E5;
double vdno = 0.2 / 1.E5;
double vdno2 = 0.5 / 1.E5;
double vdhno3 = 4. / 1.E5;
double vdrooh = 0.8 / 1.E5;
double vdh2o2 = 1.8 / 1.E5;
double vdhcho = 0.33 / 1.E5;

//Emissions   units here ar ppb m/s ---> ppb/s
double eno = 0.1 / 1.E3;
double erh = 0.5 / 1.E3;


/* End INLINED RCONST                                               */

  RCONST[0] = (ARR3(1.7E-12,-940.,TEMP));
  RCONST[1] = (ARR3(1.E-14,-490.,TEMP));
  RCONST[2] = (ARR3(4.8E-11,250.,TEMP));
  RCONST[3] = (EPR(3.E-13,460.,2.1E-33,920.,1.4E-21,2200.,C_M,C_H2O,
             TEMP));
  RCONST[4] = (ARR3(2.9E-12,-160.,TEMP));
  RCONST[5] = (ARR3(2.8E-12,-1800.,TEMP)*C_H2);
  RCONST[6] = (ARR3(3.E-12,-1500.,TEMP));
  RCONST[7] = (ARR3(3.3E-12,270.,TEMP));
  RCONST[8] = (TROE_no2oh(3.2E-30,4.5,3.E-11,10.,C_M,TEMP));
  RCONST[9] = (ARR3(2.45E-12,-1775.,TEMP));
  RCONST[10] = (ARR3(2.8E-12,300.,TEMP));
  RCONST[11] = (ARR3(3.8E-13,780.,TEMP)*(1.-(1./(1.+ARR3(498.,-1160.,
              TEMP)))));
  RCONST[12] = (ARR3(3.8E-13,780.,TEMP)*(1./(1.+ARR3(498.,-1160.,
              TEMP))));
  RCONST[13] = (ARR3(3.8E-12,200.,TEMP));
  RCONST[15] = (TROE_cooh(5.9E-33,1.4,1.1E-12,-1.3,1.5E-13,-0.6,2.1E9,
              -6.1,0.6,C_M,TEMP));
  RCONST[16] = (ARR3(5.5E-12,125.,TEMP));
  RCONST[17] = (ARR3(5.5E-15,-1880.0,TEMP));
  RCONST[18] = (k3rd_iupac(8.6E-27,3.5,3.E-11,1.,0.6,C_M,0.5,TEMP));
  RCONST[19] = (2.7E-06);
  RCONST[20] = (8.9E-03);
  RCONST[21] = (2.845E-05);
  RCONST[22] = (3.734E-05);
  RCONST[23] = (5.531E-06);
  RCONST[24] = (8.881E-06);
  RCONST[25] = (ARR3(1.4E-13,-2470.,TEMP));
  RCONST[26] = (ARR3(1.8E-11,110.,TEMP));
  RCONST[27] = (TROE_ifs(3.6E-30,4.1,1.9E-12,-0.2,10.,C_M,TEMP));
  RCONST[28] = ((TROE_ifs2(1.3E-3,-3.5,9.7E14,0.1,10.,C_M,-11000.,
              -11080.,TEMP)));
  RCONST[31] = (ARR2(4.6E-13,-1155.));
  RCONST[32] = (0.2);
  RCONST[33] = (5.151E-5);
  RCONST[34] = (erh);
  RCONST[35] = (eno);
  RCONST[36] = (vdo3);
  RCONST[37] = (vdno);
  RCONST[38] = (vdno2);
  RCONST[39] = (vdhno3);
  RCONST[40] = (vdrooh);
  RCONST[41] = (vdh2o2);
  RCONST[42] = (vdhcho);
}

/* End of Update_RCONST function                                    */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Update_PHOTO - function to update photolytical rate constants    */
/*   Arguments :                                                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void Update_PHOTO( 
)
{

  RCONST[19] = (2.7E-06);
  RCONST[20] = (8.9E-03);
  RCONST[21] = (2.845E-05);
  RCONST[22] = (3.734E-05);
  RCONST[23] = (5.531E-06);
  RCONST[24] = (8.881E-06);
  RCONST[32] = (0.2);
  RCONST[33] = (5.151E-5);
}

/* End of Update_PHOTO function                                     */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


